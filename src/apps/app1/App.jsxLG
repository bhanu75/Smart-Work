import React, { useState, useEffect } from 'react';
import { Settings, Home, RotateCcw, Volume2, VolumeX } from 'lucide-react';

// Game Constants
const COLORS = ['red', 'green', 'yellow', 'blue'];
const PLAYER_NAMES = ['You', 'Computer 2', 'Computer 3', 'Computer 4'];
const BOARD_PATH = [
  // Red start
  { x: 6, y: 13, color: 'red' }, { x: 5, y: 13 }, { x: 4, y: 13 }, { x: 3, y: 13 }, { x: 2, y: 13 },
  { x: 1, y: 13, star: true }, { x: 0, y: 13 }, { x: 0, y: 12 }, { x: 0, y: 11 },
  // Green turn
  { x: 0, y: 10 }, { x: 0, y: 9 }, { x: 0, y: 8, star: true }, { x: 0, y: 7 }, { x: 0, y: 6 },
  { x: 1, y: 6 }, { x: 2, y: 6 },
  // Green home stretch entry
  { x: 3, y: 6 }, { x: 4, y: 6 }, { x: 5, y: 6 }, { x: 6, y: 6, star: true }, { x: 7, y: 6 },
  { x: 8, y: 6 }, { x: 8, y: 5 }, { x: 8, y: 4 },
  // Yellow turn
  { x: 8, y: 3 }, { x: 8, y: 2 }, { x: 8, y: 1, star: true }, { x: 8, y: 0 }, { x: 9, y: 0 },
  { x: 10, y: 0 }, { x: 11, y: 0 }, { x: 12, y: 0 },
  // Yellow home stretch entry
  { x: 13, y: 0 }, { x: 14, y: 0 }, { x: 14, y: 1 }, { x: 14, y: 2 }, { x: 14, y: 3 },
  { x: 14, y: 4 }, { x: 14, y: 5 }, { x: 13, y: 6 },
  // Blue turn
  { x: 12, y: 6 }, { x: 11, y: 6 }, { x: 10, y: 6, star: true }, { x: 9, y: 6 }, { x: 8, y: 6 },
  { x: 8, y: 7 }, { x: 8, y: 8 }, { x: 8, y: 9 }, { x: 8, y: 10 },
  // Blue home stretch entry
  { x: 8, y: 11 }, { x: 8, y: 12 }, { x: 8, y: 13 }
];

// Home paths (final 5 squares to win)
const HOME_PATHS = {
  red: [{ x: 7, y: 13 }, { x: 7, y: 12 }, { x: 7, y: 11 }, { x: 7, y: 10 }, { x: 7, y: 9 }, { x: 7, y: 8 }],
  green: [{ x: 1, y: 7 }, { x: 2, y: 7 }, { x: 3, y: 7 }, { x: 4, y: 7 }, { x: 5, y: 7 }, { x: 6, y: 7 }],
  yellow: [{ x: 13, y: 1 }, { x: 13, y: 2 }, { x: 13, y: 3 }, { x: 13, y: 4 }, { x: 13, y: 5 }, { x: 13, y: 6 }],
  blue: [{ x: 9, y: 7 }, { x: 10, y: 7 }, { x: 11, y: 7 }, { x: 12, y: 7 }, { x: 13, y: 7 }, { x: 14, y: 7 }]
};

// Start positions on main board
const START_POSITIONS = {
  red: 0,
  green: 13,
  yellow: 26,
  blue: 39
};

const LudoGame = () => {
  const [gameState, setGameState] = useState({
    currentPlayer: 0,
    diceValue: null,
    rolling: false,
    tokens: {
      red: [{ position: -1, inHome: false }, { position: -1, inHome: false }, { position: -1, inHome: false }, { position: -1, inHome: false }],
      green: [{ position: -1, inHome: false }, { position: -1, inHome: false }, { position: -1, inHome: false }, { position: -1, inHome: false }],
      yellow: [{ position: -1, inHome: false }, { position: -1, inHome: false }, { position: -1, inHome: false }, { position: -1, inHome: false }],
      blue: [{ position: -1, inHome: false }, { position: -1, inHome: false }, { position: -1, inHome: false }, { position: -1, inHome: false }]
    },
    canMove: false,
    movableTokens: [],
    consecutiveSixes: 0,
    winner: null
  });

  const [settings, setSettings] = useState({
    showSettings: false,
    sound: true,
    winOrder: {
      green: 'random',
      yellow: 'random',
      blue: 'random'
    }
  });

  // Roll dice
  const rollDice = () => {
    if (gameState.rolling || gameState.canMove || gameState.winner) return;
    
    setGameState(prev => ({ ...prev, rolling: true }));
    
    setTimeout(() => {
      const dice = Math.floor(Math.random() * 6) + 1;
      const color = COLORS[gameState.currentPlayer];
      const movable = getMovableTokens(color, dice);
      
      let newConsecutiveSixes = dice === 6 ? gameState.consecutiveSixes + 1 : 0;
      
      // 3 consecutive sixes = turn cancelled
      if (newConsecutiveSixes === 3) {
        setGameState(prev => ({
          ...prev,
          diceValue: dice,
          rolling: false,
          consecutiveSixes: 0,
          canMove: false
        }));
        setTimeout(() => nextPlayer(), 1000);
        return;
      }
      
      setGameState(prev => ({
        ...prev,
        diceValue: dice,
        rolling: false,
        canMove: movable.length > 0,
        movableTokens: movable,
        consecutiveSixes: newConsecutiveSixes
      }));
      
      // Auto move for AI
      if (gameState.currentPlayer > 0 && movable.length > 0) {
        setTimeout(() => {
          const aiDifficulty = settings.winOrder[color];
          const tokenIndex = selectAIMove(color, movable, dice, aiDifficulty);
          moveToken(color, tokenIndex, dice);
        }, 800);
      }
    }, 500);
  };

  // Get movable tokens
  const getMovableTokens = (color, dice) => {
    const tokens = gameState.tokens[color];
    const movable = [];
    
    tokens.forEach((token, idx) => {
      if (token.position === -1 && dice === 6) {
        movable.push(idx);
      } else if (token.position >= 0 && !token.inHome) {
        const newPos = token.position + dice;
        if (newPos <= 51) {
          movable.push(idx);
        }
      } else if (token.inHome) {
        const homePath = HOME_PATHS[color];
        const homePos = token.position - 52;
        if (homePos + dice <= homePath.length) {
          movable.push(idx);
        }
      }
    });
    
    return movable;
  };

  // AI move selection based on difficulty
  const selectAIMove = (color, movableTokens, dice, difficulty) => {
    const tokens = gameState.tokens[color];
    
    if (difficulty === 'first') {
      // Aggressive: prioritize tokens closest to winning
      let best = movableTokens[0];
      let bestScore = -1;
      
      movableTokens.forEach(idx => {
        const token = tokens[idx];
        let score = token.position;
        if (token.inHome) score += 52;
        if (score > bestScore) {
          bestScore = score;
          best = idx;
        }
      });
      return best;
    } else if (difficulty === 'last') {
      // Defensive: prioritize tokens furthest from winning
      let worst = movableTokens[0];
      let worstScore = 1000;
      
      movableTokens.forEach(idx => {
        const token = tokens[idx];
        let score = token.position;
        if (token.inHome) score += 52;
        if (score < worstScore) {
          worstScore = score;
          worst = idx;
        }
      });
      return worst;
    } else {
      // Random
      return movableTokens[Math.floor(Math.random() * movableTokens.length)];
    }
  };

  // Move token
  const moveToken = (color, tokenIndex, dice) => {
    if (!gameState.canMove && gameState.currentPlayer === 0) return;
    if (!gameState.movableTokens.includes(tokenIndex)) return;
    
    setGameState(prev => {
      const newTokens = { ...prev.tokens };
      const token = { ...newTokens[color][tokenIndex] };
      let extraTurn = false;
      
      if (token.position === -1) {
        // Launch token
        token.position = 0;
        extraTurn = dice === 6;
      } else if (token.inHome) {
        // Move in home path
        const homePos = token.position - 52;
        if (homePos + dice === HOME_PATHS[color].length) {
          token.position = 52 + HOME_PATHS[color].length;
        } else {
          token.position += dice;
        }
      } else {
        // Move on main board
        const newPos = token.position + dice;
        const startPos = START_POSITIONS[color];
        const entrancePos = (startPos + 50) % 52;
        
        if (newPos >= 51 && token.position <= entrancePos && newPos > entrancePos) {
          // Enter home path
          token.inHome = true;
          token.position = 52 + (newPos - 51);
        } else {
          token.position = newPos % 52;
          
          // Check for captures
          COLORS.forEach(otherColor => {
            if (otherColor !== color) {
              newTokens[otherColor] = newTokens[otherColor].map(t => {
                const actualPos = (t.position + START_POSITIONS[otherColor]) % 52;
                const currentActualPos = (token.position + START_POSITIONS[color]) % 52;
                
                if (!t.inHome && t.position >= 0 && actualPos === currentActualPos) {
                  const safeSpots = [8, 21, 34, 47];
                  if (!safeSpots.includes(actualPos)) {
                    extraTurn = true;
                    return { ...t, position: -1 };
                  }
                }
                return t;
              });
            }
          });
        }
      }
      
      newTokens[color][tokenIndex] = token;
      
      // Check win
      const allHome = newTokens[color].every(t => t.position === 52 + HOME_PATHS[color].length);
      
      return {
        ...prev,
        tokens: newTokens,
        canMove: false,
        winner: allHome ? color : prev.winner,
        diceValue: extraTurn || dice === 6 ? prev.diceValue : null
      };
    });
    
    if (dice !== 6 && !gameState.winner) {
      setTimeout(() => nextPlayer(), 800);
    } else if (gameState.currentPlayer > 0) {
      setTimeout(() => rollDice(), 800);
    }
  };

  // Next player
  const nextPlayer = () => {
    setGameState(prev => ({
      ...prev,
      currentPlayer: (prev.currentPlayer + 1) % 4,
      diceValue: null,
      consecutiveSixes: 0
    }));
  };

  // Auto roll for AI
  useEffect(() => {
    if (gameState.currentPlayer > 0 && !gameState.rolling && !gameState.canMove && !gameState.winner) {
      setTimeout(() => rollDice(), 1000);
    }
  }, [gameState.currentPlayer, gameState.rolling, gameState.canMove]);

  // Restart game
  const restartGame = () => {
    setGameState({
      currentPlayer: 0,
      diceValue: null,
      rolling: false,
      tokens: {
        red: [{ position: -1, inHome: false }, { position: -1, inHome: false }, { position: -1, inHome: false }, { position: -1, inHome: false }],
        green: [{ position: -1, inHome: false }, { position: -1, inHome: false }, { position: -1, inHome: false }, { position: -1, inHome: false }],
        yellow: [{ position: -1, inHome: false }, { position: -1, inHome: false }, { position: -1, inHome: false }, { position: -1, inHome: false }],
        blue: [{ position: -1, inHome: false }, { position: -1, inHome: false }, { position: -1, inHome: false }, { position: -1, inHome: false }]
      },
      canMove: false,
      movableTokens: [],
      consecutiveSixes: 0,
      winner: null
    });
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-900 via-purple-900 to-blue-800 flex flex-col items-center justify-center p-2 sm:p-4">
      {/* Header */}
      <div className="w-full max-w-2xl mb-4">
        <h1 className="text-2xl sm:text-4xl font-bold text-center text-yellow-300 mb-2 drop-shadow-lg">
          4-PLAYER LUDO MVP
        </h1>
        <p className="text-center text-white text-xs sm:text-sm">One Real Player vs Three Computer AIs</p>
      </div>

      {/* Game Board */}
      <div className="relative bg-white rounded-lg shadow-2xl p-2 sm:p-4 max-w-2xl w-full">
        {/* Settings Modal */}
        {settings.showSettings && (
          <div className="absolute inset-0 bg-black bg-opacity-75 z-50 rounded-lg flex items-center justify-center p-4">
            <div className="bg-white rounded-lg p-4 sm:p-6 w-full max-w-md">
              <h2 className="text-xl sm:text-2xl font-bold mb-4">Settings</h2>
              
              <div className="space-y-4">
                <div>
                  <label className="block font-semibold mb-2">Computer 2 (Green)</label>
                  <select 
                    className="w-full border-2 rounded p-2"
                    value={settings.winOrder.green}
                    onChange={(e) => setSettings(prev => ({
                      ...prev,
                      winOrder: { ...prev.winOrder, green: e.target.value }
                    }))}
                  >
                    <option value="random">Random (Normal)</option>
                    <option value="first">Win First (Aggressive)</option>
                    <option value="last">Win Last (Defensive)</option>
                  </select>
                </div>

                <div>
                  <label className="block font-semibold mb-2">Computer 3 (Yellow)</label>
                  <select 
                    className="w-full border-2 rounded p-2"
                    value={settings.winOrder.yellow}
                    onChange={(e) => setSettings(prev => ({
                      ...prev,
                      winOrder: { ...prev.winOrder, yellow: e.target.value }
                    }))}
                  >
                    <option value="random">Random (Normal)</option>
                    <option value="first">Win First (Aggressive)</option>
                    <option value="last">Win Last (Defensive)</option>
                  </select>
                </div>

                <div>
                  <label className="block font-semibold mb-2">Computer 4 (Blue)</label>
                  <select 
                    className="w-full border-2 rounded p-2"
                    value={settings.winOrder.blue}
                    onChange={(e) => setSettings(prev => ({
                      ...prev,
                      winOrder: { ...prev.winOrder, blue: e.target.value }
                    }))}
                  >
                    <option value="random">Random (Normal)</option>
                    <option value="first">Win First (Aggressive)</option>
                    <option value="last">Win Last (Defensive)</option>
                  </select>
                </div>

                <div className="flex items-center justify-between">
                  <span className="font-semibold">Sound</span>
                  <button
                    onClick={() => setSettings(prev => ({ ...prev, sound: !prev.sound }))}
                    className="p-2 rounded-lg bg-gray-200 hover:bg-gray-300"
                  >
                    {settings.sound ? <Volume2 size={24} /> : <VolumeX size={24} />}
                  </button>
                </div>
              </div>

              <button
                onClick={() => setSettings(prev => ({ ...prev, showSettings: false }))}
                className="w-full mt-6 bg-blue-600 text-white py-3 rounded-lg font-bold hover:bg-blue-700"
              >
                Close Settings
              </button>
            </div>
          </div>
        )}

        {/* Winner Modal */}
        {gameState.winner && (
          <div className="absolute inset-0 bg-black bg-opacity-75 z-50 rounded-lg flex items-center justify-center p-4">
            <div className="bg-white rounded-lg p-6 sm:p-8 text-center">
              <h2 className="text-3xl sm:text-4xl font-bold mb-4" style={{ color: gameState.winner }}>
                {PLAYER_NAMES[COLORS.indexOf(gameState.winner)]} Wins! ðŸŽ‰
              </h2>
              <button
                onClick={restartGame}
                className="bg-green-600 text-white px-6 py-3 rounded-lg font-bold hover:bg-green-700 text-lg"
              >
                Play Again
              </button>
            </div>
          </div>
        )}

        {/* Top Controls */}
        <div className="flex justify-between items-center mb-4">
          <button
            onClick={() => setSettings(prev => ({ ...prev, showSettings: true }))}
            className="p-2 sm:p-3 bg-gray-200 rounded-lg hover:bg-gray-300"
            title="Settings"
          >
            <Settings size={20} />
          </button>
          
          <div className="text-center">
            <div className="font-bold text-sm sm:text-base" style={{ color: COLORS[gameState.currentPlayer] }}>
              {PLAYER_NAMES[gameState.currentPlayer]}'s Turn
            </div>
            {gameState.consecutiveSixes > 0 && (
              <div className="text-xs text-orange-600">
                {gameState.consecutiveSixes} six{gameState.consecutiveSixes > 1 ? 'es' : ''}!
              </div>
            )}
          </div>

          <button
            onClick={restartGame}
            className="p-2 sm:p-3 bg-red-200 rounded-lg hover:bg-red-300"
            title="Restart"
          >
            <RotateCcw size={20} />
          </button>
        </div>

        {/* Ludo Board - Simplified Visual */}
        <div className="aspect-square bg-white border-4 border-gray-800 relative mx-auto max-w-lg">
          {/* Home Bases */}
          <div className="absolute top-0 left-0 w-[40%] h-[40%] bg-green-500 border-2 border-gray-800 p-2 sm:p-4">
            <div className="grid grid-cols-2 gap-1 sm:gap-2 h-full">
              {gameState.tokens.green.map((token, idx) => (
                token.position === -1 && (
                  <div key={idx} className="bg-white rounded-full border-2 border-green-700 flex items-center justify-center">
                    <div className="w-3 h-3 sm:w-4 sm:h-4 bg-green-700 rounded-full"></div>
                  </div>
                )
              ))}
            </div>
          </div>

          <div className="absolute top-0 right-0 w-[40%] h-[40%] bg-yellow-400 border-2 border-gray-800 p-2 sm:p-4">
            <div className="grid grid-cols-2 gap-1 sm:gap-2 h-full">
              {gameState.tokens.yellow.map((token, idx) => (
                token.position === -1 && (
                  <div key={idx} className="bg-white rounded-full border-2 border-yellow-700 flex items-center justify-center">
                    <div className="w-3 h-3 sm:w-4 sm:h-4 bg-yellow-700 rounded-full"></div>
                  </div>
                )
              ))}
            </div>
          </div>

          <div className="absolute bottom-0 left-0 w-[40%] h-[40%] bg-red-500 border-2 border-gray-800 p-2 sm:p-4">
            <div className="grid grid-cols-2 gap-1 sm:gap-2 h-full">
              {gameState.tokens.red.map((token, idx) => (
                token.position === -1 && (
                  <div key={idx} className="bg-white rounded-full border-2 border-red-700 flex items-center justify-center">
                    <div className="w-3 h-3 sm:w-4 sm:h-4 bg-red-700 rounded-full"></div>
                  </div>
                )
              ))}
            </div>
          </div>

          <div className="absolute bottom-0 right-0 w-[40%] h-[40%] bg-blue-500 border-2 border-gray-800 p-2 sm:p-4">
            <div className="grid grid-cols-2 gap-1 sm:gap-2 h-full">
              {gameState.tokens.blue.map((token, idx) => (
                token.position === -1 && (
                  <div key={idx} className="bg-white rounded-full border-2 border-blue-700 flex items-center justify-center">
                    <div className="w-3 h-3 sm:w-4 sm:h-4 bg-blue-700 rounded-full"></div>
                  </div>
                )
              ))}
            </div>
          </div>

          {/* Center Cross Paths */}
          <div className="absolute top-[40%] left-[40%] w-[20%] h-[20%] bg-gradient-to-br from-yellow-300 to-red-300 border-2 border-gray-800 flex items-center justify-center">
            <Home className="text-white" size={32} />
          </div>

          {/* Token indicators on board */}
          <div className="absolute inset-0 pointer-events-none">
            {COLORS.map(color => 
              gameState.tokens[color].map((token, idx) => {
                if (token.position >= 0 && !token.inHome) {
                  const actualPos = (token.position + START_POSITIONS[color]) % 52;
                  const angle = (actualPos / 52) * 360;
                  const radius = 38;
                  const x = 50 + radius * Math.cos((angle - 90) * Math.PI / 180);
                  const y = 50 + radius * Math.sin((angle - 90) * Math.PI / 180);
                  
                  return (
                    <div
                      key={`${color}-${idx}`}
                      className={`absolute w-4 h-4 sm:w-6 sm:h-6 rounded-full border-2 border-white shadow-lg transition-all pointer-events-auto ${
                        gameState.currentPlayer === 0 && gameState.movableTokens.includes(idx) && color === 'red' ? 'cursor-pointer animate-pulse' : ''
                      }`}
                      style={{
                        backgroundColor: color,
                        left: `${x}%`,
                        top: `${y}%`,
                        transform: 'translate(-50%, -50%)'
                      }}
                      onClick={() => {
                        if (gameState.currentPlayer === 0 && color === 'red' && gameState.movableTokens.includes(idx)) {
                          moveToken(color, idx, gameState.diceValue);
                        }
                      }}
                    />
                  );
                } else if (token.inHome) {
                  const homePos = token.position - 52;
                  const homePath = HOME_PATHS[color];
                  if (homePos < homePath.length) {
                    const progress = (homePos / homePath.length) * 30 + 45;
                    let x = 50, y = 50;
                    
                    if (color === 'red') y = progress;
                    else if (color === 'green') x = 100 - progress;
                    else if (color === 'yellow') y = 100 - progress;
                    else if (color === 'blue') x = progress;
                    
                    return (
                      <div
                        key={`${color}-${idx}`}
                        className="absolute w-4 h-4 sm:w-6 sm:h-6 rounded-full border-2 border-white shadow-lg"
                        style={{
                          backgroundColor: color,
                          left: `${x}%`,
                          top: `${y}%`,
                          transform: 'translate(-50%, -50%)'
                        }}
                      />
                    );
                  }
                }
                return null;
              })
            )}
          </div>
        </div>

        {/* Dice Section */}
        <div className="mt-4 flex justify-center">
          <button
            onClick={rollDice}
            disabled={gameState.rolling || gameState.canMove || gameState.currentPlayer !== 0 || gameState.winner}
            className={`w-16 h-16 sm:w-20 sm:h-20 rounded-lg shadow-lg font-bold text-2xl sm:text-3xl transition-all ${
              gameState.rolling ? 'animate-bounce bg-gray-300' :
              gameState.currentPlayer === 0 && !gameState.canMove && !gameState.winner ? 'bg-yellow-400 hover:bg-yellow-500 cursor-pointer' :
              'bg-gray-300 cursor-not-allowed'
            }`}
          >
            {gameState.diceValue || 'ðŸŽ²'}
          </button>
        </div>

        {/* Score Display */}
        <div className="mt-4 grid grid-cols-2 sm:grid-cols-4 gap-2 text-xs sm:text-sm">
          {COLORS.map((color, idx) => {
            const homeCount = gameState.tokens[color].filter(t => t.position === 52 + HOME_PATHS[color].length).length;
            return (
              <div key={color} className={`p-2 rounded border-2 ${gameState.currentPlayer === idx ? 'border-yellow-400 bg-yellow-50' : 'border-gray-300'}`}>
                <div className="font-bold" style={{ color }}>{PLAYER_NAMES[idx]}</div>
                <div className="text-gray-600">{homeCount}/4 Home</div>
              </div>
            );
          })}
        </div>
      </div>

      {/* Instructions */}
      <div className="mt-4 text-white text-center max-w-2xl text-xs sm:text-sm">
        <p className="mb-2">Roll 6 to start. Get all 4 tokens home to win. Safe zones have stars.</p>
        <p>Configure AI difficulty in Settings!</p>
      </div>
    </div>
  );
};

export default LudoGame;