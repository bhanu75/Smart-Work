import React, { useState, useEffect } from 'react';
import { Settings, Home, RotateCcw, Volume2, VolumeX } from 'lucide-react';

const COLORS = ['red', 'green', 'yellow', 'blue'];
const PLAYER_NAMES = ['You', 'Computer 2', 'Computer 3', 'Computer 4'];
const SAFE_POSITIONS = [1, 9, 14, 22, 27, 35, 40, 48];
const STAR_POSITIONS = [8, 21, 34, 47];
const START_POSITIONS = { red: 0, green: 13, yellow: 26, blue: 39 };
const HOME_STRETCH_LENGTH = 6;

const LudoGame = () => {
  const [gameState, setGameState] = useState({
    currentPlayer: 0,
    diceValue: null,
    rolling: false,
    tokens: {
      red: Array(4).fill(null).map((_, id) => ({ id, position: -1, inHomeStretch: false, homeStretchPos: -1, isHome: false })),
      green: Array(4).fill(null).map((_, id) => ({ id, position: -1, inHomeStretch: false, homeStretchPos: -1, isHome: false })),
      yellow: Array(4).fill(null).map((_, id) => ({ id, position: -1, inHomeStretch: false, homeStretchPos: -1, isHome: false })),
      blue: Array(4).fill(null).map((_, id) => ({ id, position: -1, inHomeStretch: false, homeStretchPos: -1, isHome: false }))
    },
    canMove: false,
    movableTokens: [],
    consecutiveSixes: 0,
    winner: null
  });

  const [settings, setSettings] = useState({
    showSettings: false,
    sound: true,
    winOrder: { green: 'random', yellow: 'random', blue: 'random' }
  });

  const getMovableTokens = (color, dice) => {
    const tokens = gameState.tokens[color];
    const movable = [];
    
    tokens.forEach((token, idx) => {
      if (token.isHome) return;
      if (token.position === -1 && dice === 6) movable.push(idx);
      else if (token.inHomeStretch && token.homeStretchPos + dice <= HOME_STRETCH_LENGTH) movable.push(idx);
      else if (token.position >= 0 && !token.inHomeStretch) movable.push(idx);
    });
    
    return movable;
  };

  const rollDice = () => {
    if (gameState.rolling || gameState.canMove || gameState.winner) return;
    setGameState(prev => ({ ...prev, rolling: true }));
    
    setTimeout(() => {
      const dice = Math.floor(Math.random() * 6) + 1;
      const color = COLORS[gameState.currentPlayer];
      const movable = getMovableTokens(color, dice);
      let newConsecutiveSixes = dice === 6 ? gameState.consecutiveSixes + 1 : 0;
      
      if (newConsecutiveSixes === 3) {
        setGameState(prev => ({ ...prev, diceValue: dice, rolling: false, consecutiveSixes: 0, canMove: false }));
        setTimeout(() => nextPlayer(), 1000);
        return;
      }
      
      setGameState(prev => ({ ...prev, diceValue: dice, rolling: false, canMove: movable.length > 0, movableTokens: movable, consecutiveSixes: newConsecutiveSixes }));
      
      if (gameState.currentPlayer > 0 && movable.length > 0) {
        setTimeout(() => {
          const aiDifficulty = settings.winOrder[color];
          const tokenIndex = selectAIMove(color, movable, dice, aiDifficulty);
          moveToken(color, tokenIndex, dice);
        }, 1200);
      } else if (movable.length === 0) {
        setTimeout(() => nextPlayer(), 1000);
      }
    }, 600);
  };

  const selectAIMove = (color, movableTokens, dice, difficulty) => {
    const tokens = gameState.tokens[color];
    if (difficulty === 'first') {
      let best = movableTokens[0], bestScore = -100;
      movableTokens.forEach(idx => {
        const token = tokens[idx];
        let score = token.isHome ? 1000 : token.inHomeStretch ? 500 + token.homeStretchPos * 10 : token.position >= 0 ? token.position : -10;
        if (score > bestScore) { bestScore = score; best = idx; }
      });
      return best;
    } else if (difficulty === 'last') {
      let worst = movableTokens[0], worstScore = 1000;
      movableTokens.forEach(idx => {
        const token = tokens[idx];
        let score = token.isHome ? 1000 : token.inHomeStretch ? 500 + token.homeStretchPos * 10 : token.position >= 0 ? token.position : -10;
        if (score < worstScore) { worstScore = score; worst = idx; }
      });
      return worst;
    }
    return movableTokens[Math.floor(Math.random() * movableTokens.length)];
  };

  const moveToken = (color, tokenIndex, dice) => {
    if (!gameState.canMove && gameState.currentPlayer === 0) return;
    if (!gameState.movableTokens.includes(tokenIndex)) return;
    
    setGameState(prev => {
      const newTokens = { ...prev.tokens };
      const token = { ...newTokens[color][tokenIndex] };
      let extraTurn = false;
      
      if (token.position === -1) {
        token.position = 0;
        extraTurn = true;
      } else if (token.inHomeStretch) {
        token.homeStretchPos += dice;
        if (token.homeStretchPos === HOME_STRETCH_LENGTH) token.isHome = true;
      } else {
        const newPos = token.position + dice;
        if (newPos >= 51) {
          token.inHomeStretch = true;
          token.homeStretchPos = newPos - 51;
          if (token.homeStretchPos === HOME_STRETCH_LENGTH) token.isHome = true;
        } else {
          token.position = newPos;
          const absolutePos = (token.position + START_POSITIONS[color]) % 52;
          
          COLORS.forEach(otherColor => {
            if (otherColor !== color) {
              newTokens[otherColor] = newTokens[otherColor].map(t => {
                if (!t.inHomeStretch && t.position >= 0) {
                  const otherAbsPos = (t.position + START_POSITIONS[otherColor]) % 52;
                  if (absolutePos === otherAbsPos && !SAFE_POSITIONS.includes(absolutePos)) {
                    extraTurn = true;
                    return { ...t, position: -1 };
                  }
                }
                return t;
              });
            }
          });
        }
      }
      
      newTokens[color][tokenIndex] = token;
      const allHome = newTokens[color].every(t => t.isHome);
      
      return { ...prev, tokens: newTokens, canMove: false, movableTokens: [], winner: allHome ? color : prev.winner, diceValue: extraTurn || dice === 6 ? prev.diceValue : null };
    });
    
    if (dice !== 6 && !gameState.winner) setTimeout(() => nextPlayer(), 1000);
    else if (gameState.currentPlayer > 0 && !gameState.winner) setTimeout(() => rollDice(), 1000);
  };

  const nextPlayer = () => {
    setGameState(prev => ({ ...prev, currentPlayer: (prev.currentPlayer + 1) % 4, diceValue: null, consecutiveSixes: 0, canMove: false, movableTokens: [] }));
  };

  useEffect(() => {
    if (gameState.currentPlayer > 0 && !gameState.rolling && !gameState.canMove && !gameState.winner && !gameState.diceValue) {
      setTimeout(() => rollDice(), 1500);
    }
  }, [gameState.currentPlayer, gameState.rolling, gameState.canMove, gameState.diceValue]);

  const restartGame = () => {
    setGameState({
      currentPlayer: 0, diceValue: null, rolling: false,
      tokens: {
        red: Array(4).fill(null).map((_, id) => ({ id, position: -1, inHomeStretch: false, homeStretchPos: -1, isHome: false })),
        green: Array(4).fill(null).map((_, id) => ({ id, position: -1, inHomeStretch: false, homeStretchPos: -1, isHome: false })),
        yellow: Array(4).fill(null).map((_, id) => ({ id, position: -1, inHomeStretch: false, homeStretchPos: -1, isHome: false })),
        blue: Array(4).fill(null).map((_, id) => ({ id, position: -1, inHomeStretch: false, homeStretchPos: -1, isHome: false }))
      },
      canMove: false, movableTokens: [], consecutiveSixes: 0, winner: null
    });
  };

  const getTokenPosition = (absolutePos) => {
    let left = 50, top = 50;
    if (absolutePos < 6) { left = 6 + absolutePos * 6.67; top = 86.67; }
    else if (absolutePos < 13) { left = 6.67; top = 86.67 - (absolutePos - 6) * 6.67; }
    else if (absolutePos < 19) { left = 6.67 + (absolutePos - 13) * 6.67; top = 6.67; }
    else if (absolutePos < 26) { left = 46.67 + (absolutePos - 19) * 6.67; top = 6.67; }
    else if (absolutePos < 32) { left = 86.67; top = 6.67 + (absolutePos - 26) * 6.67; }
    else if (absolutePos < 39) { left = 86.67; top = 46.67 + (absolutePos - 32) * 6.67; }
    else if (absolutePos < 45) { left = 86.67 - (absolutePos - 39) * 6.67; top = 86.67; }
    else { left = 46.67 - (absolutePos - 45) * 6.67; top = 86.67; }
    return { left, top };
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-indigo-900 via-purple-900 to-indigo-800 flex flex-col items-center justify-center p-2 sm:p-4">
      <div className="w-full max-w-3xl">
        <h1 className="text-3xl sm:text-5xl font-bold text-center text-yellow-300 mb-2 drop-shadow-lg">4-PLAYER LUDO MVP</h1>
        <p className="text-center text-white text-sm sm:text-base mb-4">One Real Player vs Three Computer AIs</p>
      </div>

      <div className="relative bg-white rounded-2xl shadow-2xl p-3 sm:p-6 max-w-3xl w-full">
        {settings.showSettings && (
          <div className="absolute inset-0 bg-black bg-opacity-80 z-50 rounded-2xl flex items-center justify-center p-4">
            <div className="bg-white rounded-xl p-6 w-full max-w-md max-h-[80vh] overflow-y-auto">
              <h2 className="text-2xl font-bold mb-6 text-center">‚öôÔ∏è Settings</h2>
              <div className="space-y-5">
                {['green', 'yellow', 'blue'].map((color, idx) => (
                  <div key={color} className={`border-2 border-${color}-500 rounded-lg p-4`}>
                    <label className={`block font-bold mb-2 text-${color}-700`}>
                      {color === 'green' ? 'üü¢' : color === 'yellow' ? 'üü°' : 'üîµ'} Computer {idx + 2} ({color.charAt(0).toUpperCase() + color.slice(1)})
                    </label>
                    <select className="w-full border-2 rounded-lg p-3 text-base" value={settings.winOrder[color]}
                      onChange={(e) => setSettings(prev => ({ ...prev, winOrder: { ...prev.winOrder, [color]: e.target.value } }))}>
                      <option value="random">üé≤ Random (Normal)</option>
                      <option value="first">üöÄ Win First (Aggressive)</option>
                      <option value="last">üê¢ Win Last (Defensive)</option>
                    </select>
                  </div>
                ))}
                <div className="flex items-center justify-between border-2 rounded-lg p-4">
                  <span className="font-bold text-lg">üîä Sound</span>
                  <button onClick={() => setSettings(prev => ({ ...prev, sound: !prev.sound }))}
                    className={`p-3 rounded-lg ${settings.sound ? 'bg-green-500' : 'bg-gray-300'}`}>
                    {settings.sound ? <Volume2 size={24} className="text-white" /> : <VolumeX size={24} />}
                  </button>
                </div>
              </div>
              <button onClick={() => setSettings(prev => ({ ...prev, showSettings: false }))}
                className="w-full mt-6 bg-indigo-600 text-white py-4 rounded-xl font-bold text-lg hover:bg-indigo-700">
                Close Settings
              </button>
            </div>
          </div>
        )}

        {gameState.winner && (
          <div className="absolute inset-0 bg-black bg-opacity-80 z-50 rounded-2xl flex items-center justify-center p-4">
            <div className="bg-white rounded-xl p-8 text-center">
              <div className="text-6xl mb-4">üéâ</div>
              <h2 className="text-4xl font-bold mb-4" style={{ color: gameState.winner }}>
                {PLAYER_NAMES[COLORS.indexOf(gameState.winner)]} Wins!
              </h2>
              <button onClick={restartGame} className="bg-green-600 text-white px-8 py-4 rounded-xl font-bold text-xl hover:bg-green-700">
                üîÑ Play Again
              </button>
            </div>
          </div>
        )}

        <div className="flex justify-between items-center mb-4">
          <button onClick={() => setSettings(prev => ({ ...prev, showSettings: true }))}
            className="p-3 bg-gray-200 rounded-lg hover:bg-gray-300 transition">
            <Settings size={24} />
          </button>
          <div className="text-center">
            <div className="font-bold text-xl px-6 py-2 rounded-lg" style={{ backgroundColor: COLORS[gameState.currentPlayer], color: 'white' }}>
              {PLAYER_NAMES[gameState.currentPlayer]}'s Turn
            </div>
            {gameState.consecutiveSixes > 0 && (
              <div className="text-sm text-orange-600 font-bold mt-1">{gameState.consecutiveSixes} six{gameState.consecutiveSixes > 1 ? 'es' : ''}!</div>
            )}
          </div>
          <button onClick={restartGame} className="p-3 bg-red-200 rounded-lg hover:bg-red-300 transition">
            <RotateCcw size={24} />
          </button>
        </div>

        <div className="aspect-square relative mx-auto" style={{ maxWidth: '600px' }}>
          <div className="absolute inset-0 border-8 border-black">
            {/* HOME BASES */}
            {[
              { color: 'green', pos: 'top-0 left-0', label: 'Computer 2' },
              { color: 'yellow', pos: 'top-0 right-0', label: 'Computer 3' },
              { color: 'red', pos: 'bottom-0 left-0', label: 'You' },
              { color: 'blue', pos: 'bottom-0 right-0', label: 'Computer 4' }
            ].map(({ color, pos, label }) => (
              <div key={color} className={`absolute ${pos} w-[40%] h-[40%] bg-${color}-500 border-4 border-black p-4`}>
                <div className={`${color === 'yellow' ? 'text-yellow-900' : 'text-white'} font-bold text-sm sm:text-base mb-2`}>{label}</div>
                <div className="grid grid-cols-2 gap-2 h-[calc(100%-2rem)]">
                  {gameState.tokens[color].map((token, idx) => (
                    token.position === -1 && (
                      <div key={idx} className={`bg-white rounded-full border-4 border-${color}-700 flex items-center justify-center`}>
                        <div className={`w-6 h-6 sm:w-8 sm:h-8 bg-${color}-700 rounded-full`}></div>
                      </div>
                    )
                  ))}
                </div>
              </div>
            ))}

            {/* CENTER HOME */}
            <div className="absolute top-[40%] left-[40%] w-[20%] h-[20%] bg-gradient-to-br from-yellow-300 via-green-300 to-red-300 border-4 border-black flex items-center justify-center">
              <Home className="text-white drop-shadow-lg" size={40} />
            </div>

            {/* TOKENS ON BOARD */}
            {COLORS.map(color => 
              gameState.tokens[color].map((token, idx) => {
                if (token.position >= 0 && !token.inHomeStretch && !token.isHome) {
                  const absolutePos = (token.position + START_POSITIONS[color]) % 52;
                  const isMovable = gameState.movableTokens.includes(idx) && color === COLORS[gameState.currentPlayer];
                  const { left, top } = getTokenPosition(absolutePos);
                  
                  return (
                    <div key={`${color}-${idx}`}
                      className={`absolute w-6 h-6 sm:w-8 sm:h-8 rounded-full border-3 border-white shadow-lg transition-all ${
                        isMovable ? 'cursor-pointer ring-4 ring-yellow-400 animate-pulse scale-110' : ''
                      }`}
                      style={{ backgroundColor: color, left: `${left}%`, top: `${top}%`, transform: 'translate(-50%, -50%)', zIndex: isMovable ? 30 : 20 }}
                      onClick={() => isMovable && color === 'red' && moveToken(color, idx, gameState.diceValue)}
                    />
                  );
                }
                return null;
              })
            )}
          </div>
        </div>

        <div className="mt-6 flex justify-center">
          <button onClick={rollDice}
            disabled={gameState.rolling || gameState.canMove || gameState.currentPlayer !== 0 || gameState.winner}
            className={`w-20 h-20 sm:w-24 sm:h-24 rounded-xl shadow-xl font-bold text-4xl transition-all ${
              gameState.rolling ? 'animate-bounce bg-gray-400' :
              gameState.currentPlayer === 0 && !gameState.canMove && !gameState.winner ? 'bg-gray-300 hover:bg-gray-400 cursor-pointer border-4 border-gray-500' :
              'bg-gray-200 cursor-not-allowed opacity-50'
            }`}>
            {gameState.diceValue || 'üé≤'}
          </button>
        </div>

        <div className="mt-6 grid grid-cols-2 sm:grid-cols-4 gap-3">
          {COLORS.map((color, idx) => {
            const homeCount = gameState.tokens[color].filter(t => t.isHome).length;
            const currentTurn = gameState.currentPlayer === idx;
            return (
              <div key={color} 
                className={`p-3 rounded-xl border-4 transition-all ${currentTurn ? 'border-yellow-400 shadow-lg scale-105' : 'border-gray-300'}`}
                style={{ backgroundColor: currentTurn ? `${color}20` : 'white' }}>
                <div className="font-bold text-base sm:text-lg" style={{ color }}>{PLAYER_NAMES[idx]}</div>
                <div className="text-sm sm:text-base text-gray-700 font-semibold">{homeCount}/4 Home</div>
              </div>
            );
          })}
        </div>
      </div>

      <div className="mt-4 text-white text-center max-w-2xl text-sm sm:text-base px-4">
        <p className="mb-2">üé≤ Roll 6 to start. Get all 4 tokens home to win. Safe zones have stars.</p>
        <p className="font-bold">‚öôÔ∏è Configure AI difficulty in Settings!</p>
      </div>
    </div>
  );
};

export default LudoGame;